#include <click/config.h>
#include <click/logger.h>
#include <clicknet/dns.h>
#include <click/packet.hh>

#define UNUSED(expr) \
  do {               \
    (void)(expr);    \
  } while (0)

enum {
  STATE_ERROR = -1,
  STATE_END,
  STATE_DNS_NAME,
  STATE_DNS_TYPE,
  STATE_DNS_CLASS,
  STATE_DNS_TTL,
  STATE_DNS_RDLENGTH,
  STATE_DNS_RDATA
};

static inline void _print_in_addr(uint32_t addr) {
  UNUSED(addr);
  LOG_DEBUG("%d.%d.%d.%d", (addr >> 24), (addr >> 16) % 256, (addr >> 8) % 256,
            addr % 256);
}

#define MAX_LABLE_LEN 45

/** @brief DNS Question
 */
static const unsigned char *_dns_parse_queries(const unsigned char *data,
                                               const unsigned char *end,
                                               click_dns_info *dns_data) {
  char buf[1024];
  const unsigned char *p = data;
  unsigned int n_oct = 0, state = STATE_DNS_NAME, i = 0;

  for (p = data; p < end && STATE_END != state; p++) {
    if (STATE_DNS_NAME == state) {
      if (*p == 0) {
        buf[i++] = '\0';
        // ignore first ".
        LOG_DEBUG("DNS QNAME: %s", buf + 1);
        // @note only one qname is saved
        if (!dns_data->qname) {
          uint32_t q_len = strlen(buf);
          dns_data->qname = new char[q_len];
          memcpy(dns_data->qname, buf + 1, q_len);
        }
        state = STATE_DNS_TYPE;
      } else if (n_oct == 0) {
        n_oct = (unsigned int)*p;
        buf[i++] = '.';
      } else if (n_oct && end - p > n_oct) {
        memcpy(buf + i, p, n_oct);
        i += n_oct;
        p += n_oct - 1;
        n_oct = 0;
      }
    } else {
      switch (state) {
        case STATE_DNS_TYPE:
          dns_data->dns_type = ntohs(*(uint16_t *)p);
          p += 2 - 1;
          state = STATE_DNS_CLASS;
          break;
        case STATE_DNS_CLASS:
          dns_data->dns_class = ntohs(*(uint16_t *)p);
          p += 2 - 1;
          state = STATE_END;
          break;
      }
    }
  }
  return p;
}

/** @brief DNS Resource record part 2 <br/>
 * part 1 is the same as DNS Question
 */
static const unsigned char *_dns_parse_record(const unsigned char *data,
                                              const unsigned char *end,
                                              click_dns_info *info) {
  data = _dns_parse_queries(data, end, info);
  // @note ignore content if TYPE is not A or CLASS is not IN
  bool ignore =
      ((DNS_TYPE_A != info->dns_type) || (DNS_CLASS_IN != info->dns_class));
  unsigned int state = STATE_DNS_TTL;
  const unsigned char *p;
  uint16_t len = 0;
  uint32_t ttl;
  (void)ttl;

  for (p = data; p < end && STATE_END != state; p++) {
    switch (state) {
      case STATE_DNS_TTL:
        ttl = ntohl(*(uint32_t *)p);
        LOG_DEBUG("ttl %u", ttl);
        p += 4 - 1;
        state = STATE_DNS_RDLENGTH;
        break;
      case STATE_DNS_RDLENGTH:
        len = ntohs(*(uint16_t *)p);
        // @note ignore if len != 4
        ignore = ignore || (len != 4);
        p += 2 - 1;
        state = STATE_DNS_RDATA;
        break;
      case STATE_DNS_RDATA:
        if (ignore) {
          p += len - 1;
          LOG_DEBUG("ignore dns record ...");
        } else {
          info->dns_record_ip = ntohl(*(uint32_t *)p);
          LOG_DEBUG("DNSRR %u", info->dns_record_ip);
          _print_in_addr(info->dns_record_ip);
          p += 4 - 1;
        }
        state = STATE_END;
        break;
    }
  }
  return p;
}

/** @return 0 means success, other returns mean errors
 */
int dns_parse_info(const unsigned char *start, const unsigned char *end,
                   const click_dns *dh, click_dns_info *info) {
  unsigned int i;
  unsigned int count;
  // @note parse then discard. Change in the future if need parse dns
  count = ntohs(dh->dh_qdcount);
  info->dns_record_ip = 0;

  for (i = 0; i < count && start < end; i++) {
    start = _dns_parse_queries(start, end, info);
  }
  if (start >= end) {
    LOG_DEBUG("no other records");
    return 0;
  }
  // @note only parse 1 answer ...
  count = ntohs(dh->dh_ancount);
  count = 1;
  for (i = 0; i < count && start < end; i++) {
    start = _dns_parse_record(start, end, info);
  }
  return 0;
}

#ifdef BINPAC_DNS_PARSER
/* @begin */
// Add code which generated by Binpac
#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

namespace binpac {
namespace DNS {
ContextDNS::ContextDNS(DNS_Conn *connection, DNS_Flow *flow) {
  connection_ = connection;
  flow_ = flow;
}

ContextDNS::~ContextDNS() {}

DNS_Conn::DNS_Conn(click_dns_info *info) {
  upflow_ = new DNS_Flow(this, true);
  downflow_ = new DNS_Flow(this, false);
  info_ = info;
}

DNS_Conn::~DNS_Conn() {
  delete upflow_;
  upflow_ = 0;
  delete downflow_;
  downflow_ = 0;
}

void DNS_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end) {
  if (is_orig)
    upflow_->NewData(begin, end);
  else
    downflow_->NewData(begin, end);
}

void DNS_Conn::NewGap(bool is_orig, int gap_length) {
  if (is_orig)
    upflow_->NewGap(gap_length);
  else
    downflow_->NewGap(gap_length);
}

void DNS_Conn::FlowEOF(bool is_orig) {
  if (is_orig)
    upflow_->FlowEOF();
  else
    downflow_->FlowEOF();
}

DNS_PDU::DNS_PDU(bool is_orig) {
  val_case_index_ = -1;
  request_ = 0;
  response_ = 0;
  is_orig_ = is_orig;
}

DNS_PDU::~DNS_PDU() {
  switch (val_case_index()) {
    case 1:
      // Clean up "request"
      {
        delete request_;
        request_ = 0;
      }
      break;
    case 0:
      // Clean up "response"
      {
        delete response_;
        response_ = 0;
      }
      break;
  }
}

int DNS_PDU::Parse(const_byteptr const t_begin_of_data,
                   const_byteptr const t_end_of_data, ContextDNS *t_context) {
  int t_val__size;
  val_case_index_ = is_orig();
  switch (val_case_index()) {
    case 1:
      // Parse "request"
      {
        request_ = new DNS_message();
        int t_request__size;
        t_request__size =
            request_->Parse(t_begin_of_data, t_end_of_data, t_context);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_request__size;
      }
      break;
    case 0:
      // Parse "response"
      {
        response_ = new DNS_message();
        int t_response__size;
        t_response__size =
            response_->Parse(t_begin_of_data, t_end_of_data, t_context);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_response__size;
      }
      break;
    default:
      throw binpac::ExceptionInvalidCaseIndex("DNS_PDU", val_case_index());
      break;
  }
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
  return t_val__size;
}

DNS_message::DNS_message() {
  header_ = 0;
  question_ = 0;
  question__elem_ = 0;
  answer_ = 0;
  answer__elem_ = 0;
  authority_ = 0;
  authority__elem_ = 0;
  additional_ = 0;
  additional__elem_ = 0;
  byteorder_ = bigendian;
}

DNS_message::~DNS_message() {
  delete header_;
  header_ = 0;
  delete question__elem_;
  question__elem_ = 0;
  if (question()) {
    for (int i = 0; i < (int)question()->size(); ++i) {
      DNS_question *question__elem_ = (*question_)[i];
      delete question__elem_;
      question__elem_ = 0;
    }
  }
  delete question_;
  delete answer__elem_;
  answer__elem_ = 0;
  if (answer()) {
    for (int i = 0; i < (int)answer()->size(); ++i) {
      DNS_rr *answer__elem_ = (*answer_)[i];
      delete answer__elem_;
      answer__elem_ = 0;
    }
  }
  delete answer_;
  delete authority__elem_;
  authority__elem_ = 0;
  if (authority()) {
    for (int i = 0; i < (int)authority()->size(); ++i) {
      DNS_rr *authority__elem_ = (*authority_)[i];
      delete authority__elem_;
      authority__elem_ = 0;
    }
  }
  delete authority_;
  delete additional__elem_;
  additional__elem_ = 0;
  if (additional()) {
    for (int i = 0; i < (int)additional()->size(); ++i) {
      DNS_rr *additional__elem_ = (*additional_)[i];
      delete additional__elem_;
      additional__elem_ = 0;
    }
  }
  delete additional_;
}

int DNS_message::Parse(const_byteptr const t_begin_of_data,
                       const_byteptr const t_end_of_data,
                       ContextDNS *t_context) {
  sourcedata_ = const_bytestring(t_begin_of_data, t_end_of_data);
  // Checking out-of-bound for "DNS_message:header"
  if (t_begin_of_data + (12) > t_end_of_data ||
      t_begin_of_data + (12) < t_begin_of_data) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_message:header", (0) + (12),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "header"
  header_ = new DNS_header();
  header_->Parse(t_begin_of_data, t_end_of_data, t_context, byteorder());
  // Evaluate 'let' and 'withinput' fields

  // Parse "question"
  int t_question__arraylength;
  t_question__arraylength = 0;
  t_question__arraylength = header()->qdcount();
  if (t_question__arraylength < 0) {
    throw binpac::ExceptionOutOfBound("DNS_message:question",
                                      t_question__arraylength,
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Check array element quantity: DNS_message:question
  if (t_begin_of_data + (t_question__arraylength) > t_end_of_data ||
      t_begin_of_data + (t_question__arraylength) < t_begin_of_data)
    throw binpac::ExceptionOutOfBound("DNS_message:question",
                                      (t_question__arraylength),
                                      (t_end_of_data) - (t_begin_of_data));
  question__elem_ = 0;
  int t_question__elem__it;
  t_question__elem__it = 0;
  int t_question__size;
  question_ = new vector<DNS_question *>;
  question_->reserve(t_question__arraylength);
  const_byteptr t_question__elem__dataptr = (t_begin_of_data + 12);
  for (; t_question__elem__it < t_question__arraylength;
       ++t_question__elem__it) {
    question__elem_ = new DNS_question(this);
    int t_question__elem__size;
    t_question__elem__size = question__elem_->Parse(
        t_question__elem__dataptr, t_end_of_data, t_context, byteorder());
    // Evaluate 'let' and 'withinput' fields
    question_->push_back(question__elem_);
    t_question__elem__dataptr += t_question__elem__size;
    BINPAC_ASSERT(t_question__elem__dataptr <= t_end_of_data);
    question__elem_ = 0;
  }
// end_of_question:;
  t_question__size = t_question__elem__dataptr - ((t_begin_of_data + 12));
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_question =
      (t_begin_of_data + 12) + (t_question__size);
  BINPAC_ASSERT(t_dataptr_after_question <= t_end_of_data);
  // Parse "answer"
  int t_answer__arraylength;
  t_answer__arraylength = 0;
  t_answer__arraylength = header()->ancount();
  if (t_answer__arraylength < 0) {
    throw binpac::ExceptionOutOfBound("DNS_message:answer",
                                      t_answer__arraylength,
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Check array element quantity: DNS_message:answer
  if (t_begin_of_data + (t_answer__arraylength) > t_end_of_data ||
      t_begin_of_data + (t_answer__arraylength) < t_begin_of_data)
    throw binpac::ExceptionOutOfBound("DNS_message:answer",
                                      (t_answer__arraylength),
                                      (t_end_of_data) - (t_begin_of_data));
  answer__elem_ = 0;
  int t_answer__elem__it;
  t_answer__elem__it = 0;
  int t_answer__size;
  answer_ = new vector<DNS_rr *>;
  answer_->reserve(t_answer__arraylength);
  const_byteptr t_answer__elem__dataptr = t_dataptr_after_question;
  for (; t_answer__elem__it < t_answer__arraylength; ++t_answer__elem__it) {
    answer__elem_ = new DNS_rr(this, DNS_ANSWER);
    int t_answer__elem__size;
    t_answer__elem__size = answer__elem_->Parse(
        t_answer__elem__dataptr, t_end_of_data, t_context, byteorder());
    // Evaluate 'let' and 'withinput' fields
    answer_->push_back(answer__elem_);
    t_answer__elem__dataptr += t_answer__elem__size;
    BINPAC_ASSERT(t_answer__elem__dataptr <= t_end_of_data);
    answer__elem_ = 0;
  }
// end_of_answer:;
  t_answer__size = t_answer__elem__dataptr - (t_dataptr_after_question);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_answer =
      t_dataptr_after_question + (t_answer__size);
  BINPAC_ASSERT(t_dataptr_after_answer <= t_end_of_data);
  // Parse "authority"
  int t_authority__arraylength;
  t_authority__arraylength = 0;
  t_authority__arraylength = header()->nscount();
  if (t_authority__arraylength < 0) {
    throw binpac::ExceptionOutOfBound("DNS_message:authority",
                                      t_authority__arraylength,
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Check array element quantity: DNS_message:authority
  if (t_begin_of_data + (t_authority__arraylength) > t_end_of_data ||
      t_begin_of_data + (t_authority__arraylength) < t_begin_of_data)
    throw binpac::ExceptionOutOfBound("DNS_message:authority",
                                      (t_authority__arraylength),
                                      (t_end_of_data) - (t_begin_of_data));
  authority__elem_ = 0;
  int t_authority__elem__it;
  t_authority__elem__it = 0;
  int t_authority__size;
  authority_ = new vector<DNS_rr *>;
  authority_->reserve(t_authority__arraylength);
  const_byteptr t_authority__elem__dataptr = t_dataptr_after_answer;
  for (; t_authority__elem__it < t_authority__arraylength;
       ++t_authority__elem__it) {
    authority__elem_ = new DNS_rr(this, DNS_AUTHORITY);
    int t_authority__elem__size;
    t_authority__elem__size = authority__elem_->Parse(
        t_authority__elem__dataptr, t_end_of_data, t_context, byteorder());
    // Evaluate 'let' and 'withinput' fields
    authority_->push_back(authority__elem_);
    t_authority__elem__dataptr += t_authority__elem__size;
    BINPAC_ASSERT(t_authority__elem__dataptr <= t_end_of_data);
    authority__elem_ = 0;
  }
// end_of_authority:;
  t_authority__size = t_authority__elem__dataptr - (t_dataptr_after_answer);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_authority =
      t_dataptr_after_answer + (t_authority__size);
  BINPAC_ASSERT(t_dataptr_after_authority <= t_end_of_data);
  // Parse "additional"
  int t_additional__arraylength;
  t_additional__arraylength = 0;
  t_additional__arraylength = header()->arcount();
  if (t_additional__arraylength < 0) {
    throw binpac::ExceptionOutOfBound("DNS_message:additional",
                                      t_additional__arraylength,
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Check array element quantity: DNS_message:additional
  if (t_begin_of_data + (t_additional__arraylength) > t_end_of_data ||
      t_begin_of_data + (t_additional__arraylength) < t_begin_of_data)
    throw binpac::ExceptionOutOfBound("DNS_message:additional",
                                      (t_additional__arraylength),
                                      (t_end_of_data) - (t_begin_of_data));
  additional__elem_ = 0;
  int t_additional__elem__it;
  t_additional__elem__it = 0;
  int t_additional__size;
  additional_ = new vector<DNS_rr *>;
  additional_->reserve(t_additional__arraylength);
  const_byteptr t_additional__elem__dataptr = t_dataptr_after_authority;
  for (; t_additional__elem__it < t_additional__arraylength;
       ++t_additional__elem__it) {
    additional__elem_ = new DNS_rr(this, DNS_ADDITIONAL);
    int t_additional__elem__size;
    t_additional__elem__size = additional__elem_->Parse(
        t_additional__elem__dataptr, t_end_of_data, t_context, byteorder());
    // Evaluate 'let' and 'withinput' fields
    additional_->push_back(additional__elem_);
    t_additional__elem__dataptr += t_additional__elem__size;
    BINPAC_ASSERT(t_additional__elem__dataptr <= t_end_of_data);
    additional__elem_ = 0;
  }
// end_of_additional:;
  t_additional__size =
      t_additional__elem__dataptr - (t_dataptr_after_authority);
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_message__size;
  const_byteptr const t_dataptr_after_additional =
      t_dataptr_after_authority + (t_additional__size);
  BINPAC_ASSERT(t_dataptr_after_additional <= t_end_of_data);
  t_DNS_message__size = t_dataptr_after_additional - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  sourcedata_.set_end(t_begin_of_data + t_DNS_message__size);
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_message__size) <= t_end_of_data);
  return t_DNS_message__size;
}

DNS_header::DNS_header() {
  id_ = 0;
  qrop_ = 0;
  qdcount_ = 0;
  ancount_ = 0;
  nscount_ = 0;
  arcount_ = 0;
  qr_ = 0;
  opcode_ = 0;
  aa_ = 0;
  tc_ = 0;
  rd_ = 0;
  ra_ = 0;
  z_ = 0;
  rcode_ = 0;
  proc_dns_header_ = 0;
}

DNS_header::~DNS_header() {}

int DNS_header::Parse(const_byteptr const t_begin_of_data,
                      const_byteptr const t_end_of_data, ContextDNS *t_context,
                      int t_byteorder) {
  // Checking out-of-bound for "DNS_header"
  if (t_begin_of_data + (12) > t_end_of_data ||
      t_begin_of_data + (12) < t_begin_of_data) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_header", (0) + (12),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "id"
  id_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_begin_of_data)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "qrop"
  qrop_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 2))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "qdcount"
  qdcount_ =
      FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 4))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "ancount"
  ancount_ =
      FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 6))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "nscount"
  nscount_ =
      FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 8))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "arcount"
  arcount_ =
      FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 10))));
  // Evaluate 'let' and 'withinput' fields

  // Evaluate 'let' and 'withinput' fields
  qr_ = qrop() >> 15;
  opcode_ = (qrop() >> 11) & 0xf;
  aa_ = (qrop() >> 10) & 0x1;
  tc_ = (qrop() >> 9) & 0x1;
  rd_ = (qrop() >> 8) & 0x1;
  ra_ = (qrop() >> 7) & 0x1;
  z_ = (qrop() >> 4) & 0x7;
  rcode_ = qrop() & 0xf;
  proc_dns_header_ = t_context->flow()->process_dns_header(this);
  BINPAC_ASSERT(t_begin_of_data + (12) <= t_end_of_data);
  return 12;
}

DNS_question::DNS_question(DNS_message *msg) {
  qname_ = 0;
  qtype_ = 0;
  qclass_ = 0;
  msg_ = msg;
  proc_dns_question_ = 0;
}

DNS_question::~DNS_question() {
  delete qname_;
  qname_ = 0;
}

int DNS_question::Parse(const_byteptr const t_begin_of_data,
                        const_byteptr const t_end_of_data,
                        ContextDNS *t_context, int t_byteorder) {
  // Parse "qname"
  qname_ = new DNS_name(msg());
  int t_qname__size;
  t_qname__size = qname_->Parse(t_begin_of_data, t_end_of_data, t_context);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_qname = t_begin_of_data + (t_qname__size);
  BINPAC_ASSERT(t_dataptr_after_qname <= t_end_of_data);
  // Checking out-of-bound for "DNS_question:qclass"
  if ((t_dataptr_after_qname + 2) + (2) > t_end_of_data ||
      (t_dataptr_after_qname + 2) + (2) < (t_dataptr_after_qname + 2)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound(
        "DNS_question:qclass",
        (((t_dataptr_after_qname + 2) - t_begin_of_data)) + (2),
        (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "qtype"
  qtype_ =
      FixByteOrder(t_byteorder, *((uint16 const *)(t_dataptr_after_qname)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "qclass"
  qclass_ = FixByteOrder(t_byteorder,
                         *((uint16 const *)((t_dataptr_after_qname + 2))));
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_question__size;
  t_DNS_question__size = (t_dataptr_after_qname + 4) - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  proc_dns_question_ = t_context->flow()->process_dns_question(this);
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_question__size) <= t_end_of_data);
  return t_DNS_question__size;
}

DNS_name::DNS_name(DNS_message *msg) {
  labels_ = 0;
  labels__elem_ = 0;
  msg_ = msg;
}

DNS_name::~DNS_name() {
  delete labels__elem_;
  labels__elem_ = 0;
  if (labels()) {
    for (int i = 0; i < (int)labels()->size(); ++i) {
      DNS_label *labels__elem_ = (*labels_)[i];
      delete labels__elem_;
      labels__elem_ = 0;
    }
  }
  delete labels_;
}

int DNS_name::Parse(const_byteptr const t_begin_of_data,
                    const_byteptr const t_end_of_data, ContextDNS *t_context) {
  // Parse "labels"
  int t_labels__arraylength;
  t_labels__arraylength = 0;
  labels__elem_ = 0;
  int t_labels__elem__it;
  t_labels__elem__it = 0;
  int t_labels__size;
  labels_ = new vector<DNS_label *>;
  const_byteptr t_labels__elem__dataptr = t_begin_of_data;

  UNUSED(t_labels__arraylength);
  for (; /* forever */; ++t_labels__elem__it) {
    // Check &until(labels__elem__dataptr >= end_of_data)
    if (t_labels__elem__dataptr >= t_end_of_data) {
      labels__elem_ = 0;
      goto end_of_labels;
    }
    labels__elem_ = new DNS_label(msg());
    int t_labels__elem__size;
    t_labels__elem__size =
        labels__elem_->Parse(t_labels__elem__dataptr, t_end_of_data, t_context);
    // Evaluate 'let' and 'withinput' fields
    labels_->push_back(labels__elem_);
    t_labels__elem__dataptr += t_labels__elem__size;
    BINPAC_ASSERT(t_labels__elem__dataptr <= t_end_of_data);
    // Check &until( ( @$element->last@ ) )
    if ((labels__elem_->last())) {
      labels__elem_ = 0;
      goto end_of_labels;
    }
    labels__elem_ = 0;
  }
end_of_labels:;
  t_labels__size = t_labels__elem__dataptr - (t_begin_of_data);
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_name__size;
  const_byteptr const t_dataptr_after_labels =
      t_begin_of_data + (t_labels__size);
  BINPAC_ASSERT(t_dataptr_after_labels <= t_end_of_data);
  t_DNS_name__size = t_dataptr_after_labels - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_name__size) <= t_end_of_data);
  return t_DNS_name__size;
}

DNS_label::DNS_label(DNS_message *msg) {
  length_ = 0;
  data_case_index_ = -1;
  ptr_lo_ = 0;
  msg_ = msg;
  label_type_ = 0;
  last_ = 0;
  ptr_ = 0;
  has_ptr_ = 0;
  clear_pointer_set_ = 0;
  has_clear_pointer_set_ = 0;
}

DNS_label::~DNS_label() {
  switch (data_case_index()) {
    case 0:
      // Clean up "label"
      { label_.free(); }
      break;
    case 3:
      // Clean up "ptr_lo"
      {}
      break;
  }
  delete ptr_;
  ptr_ = 0;
}

int DNS_label::Parse(const_byteptr const t_begin_of_data,
                     const_byteptr const t_end_of_data, ContextDNS *t_context) {
  // Checking out-of-bound for "DNS_label:length"
  if (t_begin_of_data + (1) > t_end_of_data ||
      t_begin_of_data + (1) < t_begin_of_data) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_label:length", (0) + (1),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "length"
  length_ = *((uint8 const *)(t_begin_of_data));
  // Evaluate 'let' and 'withinput' fields

  // Parse "data"
  int t_data__size;
  label_type_ = length() >> 6;
  data_case_index_ = label_type();
  switch (data_case_index()) {
    case 0:
      // Parse "label"
      {
        int t_label__size;
        t_label__size = length();
        // Checking out-of-bound for "DNS_label:label"
        if ((t_begin_of_data + 1) + (t_label__size) > t_end_of_data ||
            (t_begin_of_data + 1) + (t_label__size) < (t_begin_of_data + 1)) {
          // Handle out-of-bound condition
          throw binpac::ExceptionOutOfBound(
              "DNS_label:label", (1) + (t_label__size),
              (t_end_of_data) - (t_begin_of_data));
        }
        {
          // Setting t_end_of_data with &length
          const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_label__size;
          UNUSED(t_end_of_data);
          int t_label_string_length;
          t_label_string_length = length();
          // check for negative sizes
          if (t_label_string_length < 0)
            throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:115",
                                                       t_label_string_length);
          label_.init((t_begin_of_data + 1), t_label_string_length);
          // Evaluate 'let' and 'withinput' fields
        }
        t_data__size = t_label__size;
      }
      break;
    case 3:
      // Parse "ptr_lo"
      {
        // Checking out-of-bound for "DNS_label:ptr_lo"
        if ((t_begin_of_data + 1) + (1) > t_end_of_data ||
            (t_begin_of_data + 1) + (1) < (t_begin_of_data + 1)) {
          // Handle out-of-bound condition
          throw binpac::ExceptionOutOfBound(
              "DNS_label:ptr_lo", (1) + (1),
              (t_end_of_data) - (t_begin_of_data));
        }
        ptr_lo_ = *((uint8 const *)((t_begin_of_data + 1)));
        // Evaluate 'let' and 'withinput' fields
        t_data__size = 1;
      }
      break;
    default:
      throw binpac::ExceptionInvalidCaseIndex("DNS_label", data_case_index());
      break;
  }
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_label__size;
  const_byteptr const t_dataptr_after_data =
      (t_begin_of_data + 1) + (t_data__size);
  BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
  t_DNS_label__size = t_dataptr_after_data - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  last_ = (length() == 0) || (label_type() == 3);
  // Parse "ptr"
  has_ptr_ = (label_type() == 3);
  if (has_ptr()) {
    ptr_ = new DNS_name(msg());
    const_byteptr t_begin_of_data, t_end_of_data;
    get_pointers(t_context->flow()->get_pointer(
                     msg()->sourcedata(), ((length() & 0x3f) << 8) | ptr_lo()),
                 &t_begin_of_data, &t_end_of_data);
    int t_ptr__size;
    t_ptr__size = ptr_->Parse(t_begin_of_data, t_end_of_data, t_context);
    UNUSED(t_ptr__size);
    // Evaluate 'let' and 'withinput' fields
  }
  has_clear_pointer_set_ = (last());
  if (has_clear_pointer_set()) {
    clear_pointer_set_ = t_context->flow()->reset_pointer_set();
  }
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_label__size) <= t_end_of_data);
  return t_DNS_label__size;
}

DNS_rr::DNS_rr(DNS_message *msg, DNS_answer_type answer_type) {
  rr_name_ = 0;
  rr_type_ = 0;
  rr_class_ = 0;
  rr_ttl_ = 0;
  rr_rdlength_ = 0;
  rr_rdata_ = 0;
  msg_ = msg;
  answer_type_ = answer_type;
  proc_dns_rr_ = 0;
}

DNS_rr::~DNS_rr() {
  delete rr_name_;
  rr_name_ = 0;
  delete rr_rdata_;
  rr_rdata_ = 0;
}

int DNS_rr::Parse(const_byteptr const t_begin_of_data,
                  const_byteptr const t_end_of_data, ContextDNS *t_context,
                  int t_byteorder) {
  // Parse "rr_name"
  rr_name_ = new DNS_name(msg());
  int t_rr_name__size;
  t_rr_name__size = rr_name_->Parse(t_begin_of_data, t_end_of_data, t_context);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_rr_name =
      t_begin_of_data + (t_rr_name__size);
  BINPAC_ASSERT(t_dataptr_after_rr_name <= t_end_of_data);
  // Checking out-of-bound for "DNS_rr:rr_rdlength"
  if ((t_dataptr_after_rr_name + 8) + (2) > t_end_of_data ||
      (t_dataptr_after_rr_name + 8) + (2) < (t_dataptr_after_rr_name + 8)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound(
        "DNS_rr:rr_rdlength",
        (((t_dataptr_after_rr_name + 8) - t_begin_of_data)) + (2),
        (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "rr_type"
  rr_type_ =
      FixByteOrder(t_byteorder, *((uint16 const *)(t_dataptr_after_rr_name)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "rr_class"
  rr_class_ = FixByteOrder(t_byteorder,
                           *((uint16 const *)((t_dataptr_after_rr_name + 2))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "rr_ttl"
  rr_ttl_ = FixByteOrder(t_byteorder,
                         *((uint32 const *)((t_dataptr_after_rr_name + 4))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "rr_rdlength"
  rr_rdlength_ = FixByteOrder(
      t_byteorder, *((uint16 const *)((t_dataptr_after_rr_name + 8))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "rr_rdata"
  rr_rdata_ = new DNS_rdata(msg(), rr_type(), rr_class());
  int t_rr_rdata__size;
  t_rr_rdata__size = rr_rdlength();
  // Checking out-of-bound for "DNS_rr:rr_rdata"
  if ((t_dataptr_after_rr_name + 10) + (t_rr_rdata__size) > t_end_of_data ||
      (t_dataptr_after_rr_name + 10) + (t_rr_rdata__size) <
          (t_dataptr_after_rr_name + 10)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound(
        "DNS_rr:rr_rdata",
        (((t_dataptr_after_rr_name + 10) - t_begin_of_data)) +
            (t_rr_rdata__size),
        (t_end_of_data) - (t_begin_of_data));
  }
  {
    // Setting t_end_of_data with &length
    const_byteptr t_end_of_data =
        (t_dataptr_after_rr_name + 10) + t_rr_rdata__size;
    rr_rdata_->Parse((t_dataptr_after_rr_name + 10), t_end_of_data, t_context,
                     t_byteorder);
    // Evaluate 'let' and 'withinput' fields
  }

  int t_DNS_rr__size;
  const_byteptr const t_dataptr_after_rr_rdata =
      (t_dataptr_after_rr_name + 10) + (t_rr_rdata__size);
  BINPAC_ASSERT(t_dataptr_after_rr_rdata <= t_end_of_data);
  t_DNS_rr__size = t_dataptr_after_rr_rdata - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  proc_dns_rr_ = t_context->flow()->process_dns_rr(this);
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_rr__size) <= t_end_of_data);
  return t_DNS_rr__size;
}

DNS_rdata::DNS_rdata(DNS_message *msg, uint16 rr_type, uint16 rr_class) {
  val_case_index_ = -1;
  type_a_ = 0;
  type_ns_ = 0;
  type_cname_ = 0;
  type_soa_ = 0;
  type_ptr_ = 0;
  type_mx_ = 0;
  type_aaaa_ = 0;
  type_aaaa__elem_ = 0;
  type_wks_ = 0;
  type_hinfo_ = 0;
  msg_ = msg;
  rr_type_ = rr_type;
  rr_class_ = rr_class;
}

DNS_rdata::~DNS_rdata() {
  switch (val_case_index()) {
    case 1:
      // Clean up "type_a"
      {}
      break;
    case 2:
      // Clean up "type_ns"
      {
        delete type_ns_;
        type_ns_ = 0;
      }
      break;
    case 5:
      // Clean up "type_cname"
      {
        delete type_cname_;
        type_cname_ = 0;
      }
      break;
    case 6:
      // Clean up "type_soa"
      {
        delete type_soa_;
        type_soa_ = 0;
      }
      break;
    case 12:
      // Clean up "type_ptr"
      {
        delete type_ptr_;
        type_ptr_ = 0;
      }
      break;
    case 15:
      // Clean up "type_mx"
      {
        delete type_mx_;
        type_mx_ = 0;
      }
      break;
    case 28:
    case 38:
      // Clean up "type_aaaa"
      { delete type_aaaa_; }
      break;
    case 11:
      // Clean up "type_wks"
      {
        delete type_wks_;
        type_wks_ = 0;
      }
      break;
    case 13:
      // Clean up "type_hinfo"
      {
        delete type_hinfo_;
        type_hinfo_ = 0;
      }
      break;
    case 16:
      // Clean up "type_txt"
      { type_txt_.free(); }
      break;
    default:
      // Clean up "unknown"
      { unknown_.free(); }
      break;
  }
}

int DNS_rdata::Parse(const_byteptr const t_begin_of_data,
                     const_byteptr const t_end_of_data, ContextDNS *t_context,
                     int t_byteorder) {
  int t_val__size;
  val_case_index_ = rr_type();
  switch (val_case_index()) {
    case 1:
      // Parse "type_a"
      {
        // Checking out-of-bound for "DNS_rdata:type_a"
        if (t_begin_of_data + (4) > t_end_of_data ||
            t_begin_of_data + (4) < t_begin_of_data) {
          // Handle out-of-bound condition
          throw binpac::ExceptionOutOfBound(
              "DNS_rdata:type_a", (0) + (4),
              (t_end_of_data) - (t_begin_of_data));
        }
        type_a_ =
            FixByteOrder(t_byteorder, *((uint32 const *)(t_begin_of_data)));
        // Evaluate 'let' and 'withinput' fields
        t_val__size = 4;
      }
      break;
    case 2:
      // Parse "type_ns"
      {
        type_ns_ = new DNS_name(msg());
        int t_type_ns__size;
        t_type_ns__size =
            type_ns_->Parse(t_begin_of_data, t_end_of_data, t_context);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_ns__size;
      }
      break;
    case 5:
      // Parse "type_cname"
      {
        type_cname_ = new DNS_name(msg());
        int t_type_cname__size;
        t_type_cname__size =
            type_cname_->Parse(t_begin_of_data, t_end_of_data, t_context);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_cname__size;
      }
      break;
    case 6:
      // Parse "type_soa"
      {
        type_soa_ = new DNS_rdata_SOA(msg());
        int t_type_soa__size;
        t_type_soa__size = type_soa_->Parse(t_begin_of_data, t_end_of_data,
                                            t_context, t_byteorder);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_soa__size;
      }
      break;
    case 12:
      // Parse "type_ptr"
      {
        type_ptr_ = new DNS_name(msg());
        int t_type_ptr__size;
        t_type_ptr__size =
            type_ptr_->Parse(t_begin_of_data, t_end_of_data, t_context);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_ptr__size;
      }
      break;
    case 15:
      // Parse "type_mx"
      {
        type_mx_ = new DNS_rdata_MX(msg());
        int t_type_mx__size;
        t_type_mx__size = type_mx_->Parse(t_begin_of_data, t_end_of_data,
                                          t_context, t_byteorder);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_mx__size;
      }
      break;
    case 28:
    case 38:
      // Parse "type_aaaa"
      {
        int t_type_aaaa__arraylength;
        t_type_aaaa__arraylength = 0;
        t_type_aaaa__arraylength = 4;
        if (t_type_aaaa__arraylength < 0) {
          throw binpac::ExceptionOutOfBound(
              "DNS_rdata:type_aaaa", t_type_aaaa__arraylength,
              (t_end_of_data) - (t_begin_of_data));
        }
        // Check bounds for static-size array: DNS_rdata:type_aaaa
        if (t_begin_of_data + ((4) * (t_type_aaaa__arraylength)) >
                t_end_of_data ||
            t_begin_of_data + ((4) * (t_type_aaaa__arraylength)) <
                t_begin_of_data)
          throw binpac::ExceptionOutOfBound(
              "DNS_rdata:type_aaaa", ((4) * (t_type_aaaa__arraylength)),
              (t_end_of_data) - (t_begin_of_data));
        type_aaaa__elem_ = 0;
        int t_type_aaaa__elem__it;
        t_type_aaaa__elem__it = 0;
        type_aaaa_ = new vector<uint32>;
        type_aaaa_->reserve(t_type_aaaa__arraylength);
        const_byteptr t_type_aaaa__elem__dataptr = t_begin_of_data;
        for (; t_type_aaaa__elem__it < t_type_aaaa__arraylength;
             ++t_type_aaaa__elem__it) {
          type_aaaa__elem_ = FixByteOrder(
              t_byteorder, *((uint32 const *)(t_type_aaaa__elem__dataptr)));
          // Evaluate 'let' and 'withinput' fields
          type_aaaa_->push_back(type_aaaa__elem_);
          t_type_aaaa__elem__dataptr += 4;
          BINPAC_ASSERT(t_type_aaaa__elem__dataptr <= t_end_of_data);
        }
      // end_of_type_aaaa:; // Not used
        // Evaluate 'let' and 'withinput' fields
        t_val__size = 16;
      }
      break;
    case 11:
      // Parse "type_wks"
      {
        type_wks_ = new DNS_rdata_WKS();
        int t_type_wks__size;
        t_type_wks__size =
            type_wks_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_wks__size;
      }
      break;
    case 13:
      // Parse "type_hinfo"
      {
        type_hinfo_ = new DNS_rdata_HINFO();
        int t_type_hinfo__size;
        t_type_hinfo__size = type_hinfo_->Parse(t_begin_of_data, t_end_of_data);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_hinfo__size;
      }
      break;
    case 16:
      // Parse "type_txt"
      {
        int t_type_txt_string_length;
        t_type_txt_string_length = (t_end_of_data) - (t_begin_of_data);
        int t_type_txt__size;
        t_type_txt__size = t_type_txt_string_length;
        // check for negative sizes
        if (t_type_txt_string_length < 0)
          throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:177",
                                                     t_type_txt_string_length);
        type_txt_.init(t_begin_of_data, t_type_txt_string_length);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_type_txt__size;
      }
      break;
    default:
      // Parse "unknown"
      {
        int t_unknown_string_length;
        t_unknown_string_length = (t_end_of_data) - (t_begin_of_data);
        int t_unknown__size;
        t_unknown__size = t_unknown_string_length;
        // check for negative sizes
        if (t_unknown_string_length < 0)
          throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:188",
                                                     t_unknown_string_length);
        unknown_.init(t_begin_of_data, t_unknown_string_length);
        // Evaluate 'let' and 'withinput' fields
        t_val__size = t_unknown__size;
      }
      break;
  }
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
  return t_val__size;
}

DNS_char_string::DNS_char_string() { length_ = 0; }

DNS_char_string::~DNS_char_string() { data_.free(); }

int DNS_char_string::Parse(const_byteptr const t_begin_of_data,
                           const_byteptr const t_end_of_data) {
  // Checking out-of-bound for "DNS_char_string:length"
  if (t_begin_of_data + (1) > t_end_of_data ||
      t_begin_of_data + (1) < t_begin_of_data) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_char_string:length", (0) + (1),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "length"
  length_ = *((uint8 const *)(t_begin_of_data));
  // Evaluate 'let' and 'withinput' fields

  // Parse "data"
  int t_data__size;
  t_data__size = length();
  // Checking out-of-bound for "DNS_char_string:data"
  if ((t_begin_of_data + 1) + (t_data__size) > t_end_of_data ||
      (t_begin_of_data + 1) + (t_data__size) < (t_begin_of_data + 1)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_char_string:data",
                                      (1) + (t_data__size),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  {
    // Setting t_end_of_data with &length
    const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_data__size;
    UNUSED(t_end_of_data);
    int t_data_string_length;
    t_data_string_length = length();
    // check for negative sizes
    if (t_data_string_length < 0)
      throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:193",
                                                 t_data_string_length);
    data_.init((t_begin_of_data + 1), t_data_string_length);
    // Evaluate 'let' and 'withinput' fields
  }

  int t_DNS_char_string__size;
  const_byteptr const t_dataptr_after_data =
      (t_begin_of_data + 1) + (t_data__size);
  BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
  t_DNS_char_string__size = t_dataptr_after_data - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_char_string__size) <= t_end_of_data);
  return t_DNS_char_string__size;
}

DNS_rdata_MX::DNS_rdata_MX(DNS_message *msg) {
  preference_ = 0;
  name_ = 0;
  msg_ = msg;
}

DNS_rdata_MX::~DNS_rdata_MX() {
  delete name_;
  name_ = 0;
}

int DNS_rdata_MX::Parse(const_byteptr const t_begin_of_data,
                        const_byteptr const t_end_of_data,
                        ContextDNS *t_context, int t_byteorder) {
  // Checking out-of-bound for "DNS_rdata_MX:preference"
  if (t_begin_of_data + (2) > t_end_of_data ||
      t_begin_of_data + (2) < t_begin_of_data) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_rdata_MX:preference", (0) + (2),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "preference"
  preference_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_begin_of_data)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "name"
  name_ = new DNS_name(msg());
  int t_name__size;
  t_name__size = name_->Parse((t_begin_of_data + 2), t_end_of_data, t_context);
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_rdata_MX__size;
  const_byteptr const t_dataptr_after_name =
      (t_begin_of_data + 2) + (t_name__size);
  BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
  t_DNS_rdata_MX__size = t_dataptr_after_name - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_MX__size) <= t_end_of_data);
  return t_DNS_rdata_MX__size;
}

DNS_rdata_SOA::DNS_rdata_SOA(DNS_message *msg) {
  mname_ = 0;
  rname_ = 0;
  serial_ = 0;
  refresh_ = 0;
  retry_ = 0;
  expire_ = 0;
  minimum_ = 0;
  msg_ = msg;
}

DNS_rdata_SOA::~DNS_rdata_SOA() {
  delete mname_;
  mname_ = 0;
  delete rname_;
  rname_ = 0;
}

int DNS_rdata_SOA::Parse(const_byteptr const t_begin_of_data,
                         const_byteptr const t_end_of_data,
                         ContextDNS *t_context, int t_byteorder) {
  // Parse "mname"
  mname_ = new DNS_name(msg());
  int t_mname__size;
  t_mname__size = mname_->Parse(t_begin_of_data, t_end_of_data, t_context);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_mname = t_begin_of_data + (t_mname__size);
  BINPAC_ASSERT(t_dataptr_after_mname <= t_end_of_data);
  // Parse "rname"
  rname_ = new DNS_name(msg());
  int t_rname__size;
  t_rname__size =
      rname_->Parse(t_dataptr_after_mname, t_end_of_data, t_context);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_rname =
      t_dataptr_after_mname + (t_rname__size);
  BINPAC_ASSERT(t_dataptr_after_rname <= t_end_of_data);
  // Checking out-of-bound for "DNS_rdata_SOA:minimum"
  if ((t_dataptr_after_rname + 16) + (4) > t_end_of_data ||
      (t_dataptr_after_rname + 16) + (4) < (t_dataptr_after_rname + 16)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound(
        "DNS_rdata_SOA:minimum",
        (((t_dataptr_after_rname + 16) - t_begin_of_data)) + (4),
        (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "serial"
  serial_ =
      FixByteOrder(t_byteorder, *((uint32 const *)(t_dataptr_after_rname)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "refresh"
  refresh_ = FixByteOrder(t_byteorder,
                          *((uint32 const *)((t_dataptr_after_rname + 4))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "retry"
  retry_ = FixByteOrder(t_byteorder,
                        *((uint32 const *)((t_dataptr_after_rname + 8))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "expire"
  expire_ = FixByteOrder(t_byteorder,
                         *((uint32 const *)((t_dataptr_after_rname + 12))));
  // Evaluate 'let' and 'withinput' fields

  // Parse "minimum"
  minimum_ = FixByteOrder(t_byteorder,
                          *((uint32 const *)((t_dataptr_after_rname + 16))));
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_rdata_SOA__size;
  t_DNS_rdata_SOA__size = (t_dataptr_after_rname + 20) - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_SOA__size) <= t_end_of_data);
  return t_DNS_rdata_SOA__size;
}

DNS_rdata_WKS::DNS_rdata_WKS() {
  address_ = 0;
  protocol_ = 0;
}

DNS_rdata_WKS::~DNS_rdata_WKS() { bitmap_.free(); }

int DNS_rdata_WKS::Parse(const_byteptr const t_begin_of_data,
                         const_byteptr const t_end_of_data, int t_byteorder) {
  // Checking out-of-bound for "DNS_rdata_WKS:protocol"
  if ((t_begin_of_data + 4) + (1) > t_end_of_data ||
      (t_begin_of_data + 4) + (1) < (t_begin_of_data + 4)) {
    // Handle out-of-bound condition
    throw binpac::ExceptionOutOfBound("DNS_rdata_WKS:protocol", (4) + (1),
                                      (t_end_of_data) - (t_begin_of_data));
  }
  // Parse "address"
  address_ = FixByteOrder(t_byteorder, *((uint32 const *)(t_begin_of_data)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "protocol"
  protocol_ = *((uint8 const *)((t_begin_of_data + 4)));
  // Evaluate 'let' and 'withinput' fields

  // Parse "bitmap"
  int t_bitmap_string_length;
  t_bitmap_string_length = (t_end_of_data) - ((t_begin_of_data + 5));
  int t_bitmap__size;
  t_bitmap__size = t_bitmap_string_length;
  // check for negative sizes
  if (t_bitmap_string_length < 0)
    throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:214",
                                               t_bitmap_string_length);
  bitmap_.init((t_begin_of_data + 5), t_bitmap_string_length);
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_rdata_WKS__size;
  const_byteptr const t_dataptr_after_bitmap =
      (t_begin_of_data + 5) + (t_bitmap__size);
  BINPAC_ASSERT(t_dataptr_after_bitmap <= t_end_of_data);
  t_DNS_rdata_WKS__size = t_dataptr_after_bitmap - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_WKS__size) <= t_end_of_data);
  return t_DNS_rdata_WKS__size;
}

DNS_rdata_HINFO::DNS_rdata_HINFO() {
  cpu_ = 0;
  os_ = 0;
}

DNS_rdata_HINFO::~DNS_rdata_HINFO() {
  delete cpu_;
  cpu_ = 0;
  delete os_;
  os_ = 0;
}

int DNS_rdata_HINFO::Parse(const_byteptr const t_begin_of_data,
                           const_byteptr const t_end_of_data) {
  // Parse "cpu"
  cpu_ = new DNS_char_string();
  int t_cpu__size;
  t_cpu__size = cpu_->Parse(t_begin_of_data, t_end_of_data);
  // Evaluate 'let' and 'withinput' fields

  const_byteptr const t_dataptr_after_cpu = t_begin_of_data + (t_cpu__size);
  BINPAC_ASSERT(t_dataptr_after_cpu <= t_end_of_data);
  // Parse "os"
  os_ = new DNS_char_string();
  int t_os__size;
  t_os__size = os_->Parse(t_dataptr_after_cpu, t_end_of_data);
  // Evaluate 'let' and 'withinput' fields

  int t_DNS_rdata_HINFO__size;
  const_byteptr const t_dataptr_after_os = t_dataptr_after_cpu + (t_os__size);
  BINPAC_ASSERT(t_dataptr_after_os <= t_end_of_data);
  t_DNS_rdata_HINFO__size = t_dataptr_after_os - t_begin_of_data;
  // Evaluate 'let' and 'withinput' fields
  BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_HINFO__size) <= t_end_of_data);
  return t_DNS_rdata_HINFO__size;
}

int add_to_name_buffer(DNS_name *name, char *buf, const int buf_n, int buf_i) {
  for (int i = 0; i < int(name->labels()->size()); ++i) {
    DNS_label *label = (*name->labels())[i];
    if (label->label_type() == 0) {
      bytestring const &label_str = label->label();
      if (buf_i > 0 && buf_i < buf_n) buf[buf_i++] = '.';
      BINPAC_ASSERT(buf_i + label_str.length() <= buf_n);
      memcpy(buf + buf_i, label_str.begin(), label_str.length());
      buf_i += label_str.length();
    } else if (label->label_type() == 3) {
      return add_to_name_buffer(label->ptr(), buf, buf_n, buf_i);
    }
  }

  return buf_i;
}

DNS_Flow::DNS_Flow(DNS_Conn *connection, bool is_orig) {
  connection_ = connection;
  is_orig_ = is_orig;
  dataunit_ = 0;
  context_ = 0;
}

DNS_Flow::~DNS_Flow() {
  delete dataunit_;
  dataunit_ = 0;
  delete context_;
  context_ = 0;
}

void DNS_Flow::NewData(const_byteptr t_begin_of_data,
                       const_byteptr t_end_of_data) {
  try {
    dataunit_ = new DNS_PDU(is_orig());
    context_ = new ContextDNS(connection(), this);
    int t_dataunit__size;
    t_dataunit__size =
        dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
    // Evaluate 'let' and 'withinput' fields
    UNUSED(t_dataunit__size);
    delete dataunit_;
    dataunit_ = 0;
    delete context_;
    context_ = 0;
  } catch (binpac::Exception const &e) {
    delete dataunit_;
    dataunit_ = 0;
    delete context_;
    context_ = 0;
    throw;
  }
}

void DNS_Flow::NewGap(int gap_length) { UNUSED(gap_length); }

void DNS_Flow::FlowEOF() {}

const_bytestring DNS_Flow::get_pointer(const_bytestring const &msgdata,
                                       int offset) {
  if (offset < 0 || offset >= msgdata.length()) return const_bytestring(0, 0);

  if (pointer_set.find(offset) != pointer_set.end())
    throw Exception("DNS pointer loop!");

  pointer_set.insert(offset);
  return const_bytestring(msgdata.begin() + offset, msgdata.end());
}

bool DNS_Flow::reset_pointer_set() {
  pointer_set.clear();
  return true;
}

bool DNS_Flow::process_dns_header(DNS_header *hdr) {
  DNS_header *header = hdr;
  UNUSED(header);
  connection()->info()->dh_ancount = hdr->ancount();
  return true;
}

bool DNS_Flow::process_dns_question(DNS_question *question) {
  DNS_message *msg = question->msg();
  UNUSED(msg);
  click_dns_info *info = connection()->info();
  char name_buf[520];

  int n = add_to_name_buffer(question->qname(), name_buf, sizeof(name_buf), 0);
  if (n > 0) {
    --n;
  }
  BINPAC_ASSERT(n < int(sizeof(name_buf)));
  name_buf[n] = '\0';

  info->qname = new char[n];
  memcpy(info->qname, name_buf, n);
  info->dns_type = question->qtype();
  info->dns_class = question->qclass();

  LOG_DEBUG("DNS QNAME: %s", info->qname);
  LOG_DEBUG("DNS Type: %d\n", info->dns_type);
  LOG_DEBUG("DNS Class: %d\n", info->dns_class);
  return true;
}

bool DNS_Flow::process_dns_rr(DNS_rr *rr) {
  const DNS_rdata *rd = rr->rr_rdata();

  switch (rr->rr_type()) {
    case TYPE_A:
      if (rr->answer_type() == DNS_ANSWER) {
        uint32 addr = rd->type_a();
        connection()->info()->dns_record_ip = addr;
        _print_in_addr(connection()->info()->dns_record_ip);
      }
      break;

    case TYPE_A6:
      break;

    case TYPE_AAAA:
      break;

    case TYPE_NS:
      break;

    case TYPE_CNAME:
      break;

    case TYPE_SOA:
      break;

    case TYPE_PTR:
      break;

    case TYPE_MX:
      break;

    case TYPE_EDNS:
      break;
  }

  return true;
}

}  // namespace DNS
}  // namespace binpac

/* @end */
#endif